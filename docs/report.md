# Отчет

Для исследования приложения мы написали несколько python скриптов, которые запускают под капотом системные утилиты для анализа, автоматически собирают данные и
проводят анализ результатов. Отдельно мы написали скрипт для визуализации результатов. После анализа собранных метрик, мы дополнительно запустили некоторые системыные утилиты в ручном режиме, чтобы убедиться в корректности результатов. 

Для устойчивости мы запускали анализ многократно и проводили исследование на разных интервалах времени: 100, 300, 600, 1200, 2400, 6000 секунд.
Некоторые проблемы были выявлены только на длительном промежутке тестирования.

# Результаты исследования и визуализации собранных данных

## Анализ базовых системных метрик, утилизации CPU и активности потоков

График использования CPU растет линейно со временем и коррелирует с ростом памяти (см. далее). Соотношение system time к user time в среднем около 17%, в некоторых 
системах такое можно счесть слишком высоким соотношением. Кроме того, происходит несколько необъяснимых всплесков system time за время тестирования. Высокий system time
указывает на большое количество системных вызовов. Рост использования процессора скорее всего связан с ростом объема обрабатываемых данных, возможно приложение 
бесконечно аллоцирует память без освобождения или накапливает внутри себя данные без выгрузки на диск. Оба варианта не очень хорошо влияют на производительность.

![Анализ cpu](/docs/images/cpu_analysis.png)

Приложение занимает почти максимальное количество потоков на машине, причем если обратить внимание на состояние потоков -- большая часть из них просто спит большую часть времени. Количество переключений контекста периодически испытывает всплески. Такое поведение может указывать как на нормальную работу многопоточного серверного приложения, которое ожидает каких-то соединений, так и на неоптимальное использование потоков. Потенциально можно сократить количество потоков.

![Анализ потоков](/docs/images/thread_analysis.png)

## Анализ памяти и диска

Здесь мы можем видеть, что запись в операциях I/O держится на стабильно-высоком уровне, в то время, как чтения не происходит вообще. Это можно косвенно объяснить тем, что
серверное приложение пишет логи, но возможна еще какая-то запись. В любом случае множество мелких операций постоянно нагружают I/O, потенцильно нагружают шину данных и могут триггерить ненужное переключение контекста. Возможно операции записи на диск лучше проводить батчами.

![Анализ диска](/docs/images/disk_analysis.png)

Заметим, что RSS растет линейно от времени, что указывает на утечку памяти в приложении. Приложение явно регулярно аллоцирует память и не освобождает ее.
Здесь же можно заметить высокий rate page faults. Приложение постоянно обращается к новым страницам памяти. Это дополнительное косвенное свидетельство
утечки.

![Анализ оперативной памяти](/docs/images/memory_analysis.png)

## Анализ сетевого стека

NET_RX держится стабильно на одном уровне, периодически происходят всплески. Скорее всего приложение только принимает данные по сети, но почти ничего не отправляет.

![Анализ прерываний](/docs/images/interrupt_analysis.png)

На графиках Recv-Q и Send-Q происходят периодические всплески, причем одновременно. Потенциально это может указывать на большое количество time-wait соединений. Приложение
создает много коротких TCP-соединений, не переиспользует их, таким образом TCP используется неэффективно, каждое соединение проходит полный цикл инициализации, установки и закрытия.

![Анализ tcp](/docs/images/tcp_analysis.png)

# Выводы

Основная проблема приложения -- утечка данных и множество мелких I/O операций. На втором месте стоит неоптимальное использование (непереиспользование) TCP-соединений.